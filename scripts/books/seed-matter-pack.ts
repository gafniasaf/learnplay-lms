import { createClient } from "@supabase/supabase-js";
import { loadLocalEnvForTests } from "../../tests/helpers/load-local-env";
import { validateMatterPack } from "../../src/lib/books/bookMatterCore.js";

loadLocalEnvForTests();

function requireEnv(name: string): string {
  const v = process.env[name];
  if (!v || typeof v !== "string" || !v.trim()) {
    console.error(`BLOCKED: ${name} is REQUIRED`);
    process.exit(1);
  }
  return v.trim();
}

function requireId(name: string, raw: unknown): string {
  const v = String(raw || "").trim();
  if (!v) {
    console.error(`BLOCKED: ${name} is REQUIRED`);
    process.exit(1);
  }
  return v;
}

async function main() {
  const bookId = requireId("bookId", process.argv[2]);
  const bookVersionId = requireId("bookVersionId", process.argv[3]);
  if (!bookId || !bookVersionId) {
    console.error("Usage: npx tsx scripts/books/seed-matter-pack.ts <bookId> <bookVersionId>");
    process.exit(1);
  }

  // Prefer VITE_SUPABASE_URL (frontend), fall back to SUPABASE_URL (backend). Not a silent fallback: requireEnv fails loud.
  const SUPABASE_URL = (() => {
    const v = process.env.VITE_SUPABASE_URL?.trim();
    if (v) return v.replace(/\/$/, "");
    return requireEnv("SUPABASE_URL").replace(/\/$/, "");
  })();
  const SERVICE_KEY = requireEnv("SUPABASE_SERVICE_ROLE_KEY");

  const supabase = createClient(SUPABASE_URL, SERVICE_KEY, { auth: { persistSession: false, autoRefreshToken: false } });

  // Prefer skeleton meta as the canonical source for language/title in skeleton-first mode.
  const skeletonPath = `books/${bookId}/${bookVersionId}/skeleton.json`;
  const { data: skBlob, error: skErr } = await supabase.storage.from("books").download(skeletonPath);
  if (skErr || !skBlob) throw new Error(`BLOCKED: skeleton.json missing at ${skeletonPath}`);
  const skeleton = JSON.parse(await skBlob.text());
  const meta = skeleton?.meta || {};
  const title = typeof meta?.title === "string" ? meta.title.trim() : "";
  const level = typeof meta?.level === "string" ? meta.level.trim() : "";
  const language = typeof meta?.language === "string" ? meta.language.trim() : "";
  if (!title) throw new Error("BLOCKED: skeleton.meta.title is REQUIRED");
  if (level !== "n3" && level !== "n4") throw new Error("BLOCKED: skeleton.meta.level must be n3|n4");
  if (!language) throw new Error("BLOCKED: skeleton.meta.language is REQUIRED");

  const pack = {
    schemaVersion: "matter_pack_v1",
    bookId,
    bookVersionId,
    language,
    theme: {
      pageWidthMm: 195,
      pageHeightMm: 265,
      colors: {
        hboDonkerblauw: "#0F2A4A",
        vpGroen: "#2D7A4E",
        vpGroenLight: "#E9F6EE",
        textBlack: "#0F172A",
        textGray: "#334155",
        textLightGray: "#94A3B8",
        bgWhite: "#FFFFFF",
        bgOffWhite: "#F8FAFC",
        accentBlue: "#2563EB",
      },
    },
    titlePage: {
      titleHtml: title.replace(/\n/g, "<br/>"),
      authors: ["IgniteZero Testbook"],
      logoText: "EDU",
    },
    colophon: {
      isbn: "TEST-ISBN",
      nur: "000",
      trefwoorden: "testboek; bookgen; mbo",
      blocks: [
        `Titel: ${title}`,
        `Niveau: ${level.toUpperCase()}`,
        `Taal: ${language}`,
        "IgniteZero (test)",
        "Generated by IgniteZero pipeline",
      ],
      legalText: "Test artifact only. Not for distribution.",
    },
    toc: {
      title: "Inhoudsopgave",
      preamble: [
        { label: "Titelpagina", page: "—" },
        { label: "Colofon", page: "—" },
      ],
    },
    promo: {
      enabled: true,
      title: "MBOLEREN.NL",
      paragraphs: [
        "Dit is een testboek om de volledige PDF-pipeline te valideren.",
        "De inhoud, TOC en index worden automatisch gekoppeld aan paginanummers tijdens rendering.",
      ],
      ctaLabel: "Meer informatie",
      bullets: ["TOC met echte paginanummers", "Index + begrippenlijst", "Placeholder-figuren"],
    },
    index: { title: "Register" },
    glossary: { title: "Begrippenlijst", footerLabel: "BEGRIPPEN" },
  };

  const v = validateMatterPack(pack);
  if (!v.ok) {
    throw new Error(`BLOCKED: Invalid matter-pack.json: ${v.issues.map((i: any) => i.message).join("; ")}`);
  }

  const outPath = `books/${bookId}/${bookVersionId}/matter/matter-pack.json`;
  const blob = new Blob([JSON.stringify(pack, null, 2)], { type: "application/json" });
  const { error: upErr } = await supabase.storage.from("books").upload(outPath, blob, {
    upsert: true,
    contentType: "application/json",
    cacheControl: "no-cache",
  });
  if (upErr) throw new Error(upErr.message);

  console.log("✅ Seeded matter-pack.json at", outPath);
}

main().catch((e) => {
  const msg = e instanceof Error ? e.message : String(e);
  console.error(`❌ seed-matter-pack failed: ${msg}`);
  process.exit(1);
});


