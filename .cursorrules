# üß† SYSTEM CONTEXT (PRIORITY ZERO)

**CRITICAL:** Before answering any architectural question or writing code, YOU MUST READ `docs/AI_CONTEXT.md`.

This file contains the specific architectural invariants of Ignite Zero that override general coding knowledge.

## üïµÔ∏è DIAGNOSTIC PROTOCOL (PRIORITY ONE)

**When asked to "Debug," "Fix," "Troubleshoot," or "Why is X failing?":**

1.  **HALT.** Do NOT read source code immediately.
2.  **DIAGNOSE RUNTIME STATE.** Call the appropriate `lms` tool to gather evidence:
    *   **System/Connection Issues:** `lms.health()`
    *   **Job/Task Failures:** `lms.listJobs({ status: 'failed' })` + `lms.logs({ jobId: '...' })`
    *   **Content/Data Issues:** `lms.getCourse({ id: '...' })`
3.  **ANALYZE.** Form a hypothesis based on the *logs* and *state*.
    *   *Example:* "Job failed with 404" -> Check Edge Function deployment, not just job logic.
4.  **TARGET.** Only *after* diagnosing, read the specific file implicated by the evidence.

**Anti-Pattern:** Reading `index.ts` or `strategies/` files before confirming the system is healthy.

## üîÑ The Autonomous Refactor Loop

**When asked to "Refactor to [Domain]":**

1.  **Update Manifest:** Modify `system-manifest.json` to match the new domain.
2.  **Scaffold:** Run `npx tsx scripts/scaffold-manifest.ts` to regenerate contracts.
3.  **The Repair Loop:**

    * Run `npm run verify`.
    * If **FAIL**: Read the error log. Fix the specific components causing the error (rename files, map props). **Repeat.**
    * If **PASS**: Stop. The refactor is complete. Ask for human review.

## üß™ Architect Edge Contracts

- When editing `supabase/functions/architect-advisor` or introducing a new architect mode, update `tests/integration/architect-contract.spec.ts` **before** wiring UI changes.
- `scripts/verify.ts` runs this suite automatically; do not skip it. If you add/remove modes, extend both the contract test and the verify script so every mode has coverage.

## üö´ CONFIGURATION ANTI-PATTERNS (NEVER DO THIS)

**NEVER hardcode environment-specific values to "make it work".**

```typescript
// ‚ùå FORBIDDEN - Hardcoded bypass
const forceEdge = true; // "temporary fix"
const API_URL = "https://prod.example.com"; // hardcoded

// ‚úÖ REQUIRED - Use environment variables
const useEdge = import.meta.env.VITE_USE_EDGE === 'true';
const API_URL = import.meta.env.VITE_API_URL;
```

If something doesn't work locally:
1. FIRST: auto-discover required secrets from local env files (see "Secrets & Env Resolution")
2. If still missing: FAIL LOUD (BLOCKED) with the exact env var name(s) required
3. DON'T hardcode a bypass

## üö® ABSOLUTE NO-FALLBACK POLICY (PRIORITY ZERO)

**This is a BLOCKING rule. Violations will cause system failures.**

### NEVER write fallback patterns:
```typescript
// ‚ùå INSTANT REJECTION - These patterns are FORBIDDEN:
const TOKEN = process.env.TOKEN || 'dev-local-secret';
const TOKEN = process.env.TOKEN || 'placeholder-token';
const orgId = user.org_id ?? 'default';
if (process.env.ALLOW_ANON === 'true') { /* skip auth */ }
if (!data) return mockData; // silent fallback
```

### ALWAYS fail explicitly:
```typescript
// ‚úÖ REQUIRED PATTERN:
const TOKEN = process.env.TOKEN;
if (!TOKEN) {
  console.error("‚ùå TOKEN is REQUIRED - set env var before running");
  process.exit(1);
}
```

### Why:
- Fallbacks hide bugs and cause debugging nightmares
- Default tokens/orgs are security vulnerabilities
- Tests pass but production fails
- Multi-tenant data can get mixed

**When you see a fallback pattern in existing code: REMOVE IT.**

---

## üîê Secrets & Env Resolution (MANDATORY, NO USER NAGGING)

**Rule:** When a secret/credential is required, **do not ask the user first**. Attempt to resolve it from local env files **silently** (never print secret values). If not found, **report BLOCKED** and list the exact env var(s) required.

**Search order (highest priority first):**
1. `process.env.*` (already set in the current shell)
2. `supabase/.deploy.env` (local-only, gitignored)
3. `learnplay.env` (local-only, gitignored)
4. `.env`, `.env.local`, `.env.development`, `.env.production` (if present)

**Hard rules:**
- NEVER print secrets to the console/logs.
- NEVER commit secrets (tokens, service-role keys, DB passwords, API keys).
- If a required secret is missing after checking the env files: **BLOCKED** (no ‚Äúbest effort‚Äù).

---

## üóÉÔ∏è Database Migrations (ALWAYS APPLY OR BLOCK)

**Rule:** If we add/change anything that implies a DB schema change (migrations, RLS, types, tables, columns), we must **apply migrations to the target Supabase project immediately**.

**Allowed ways to apply:**
- Supabase CLI (linked project) or repo deploy scripts
- Supabase Management API (requires `SUPABASE_ACCESS_TOKEN` / PAT)

**If credentials are missing:** do NOT ‚Äúhalf-fix‚Äù in code. Report **BLOCKED** and specify:
- `SUPABASE_ACCESS_TOKEN` (PAT) and/or
- `SUPABASE_PROJECT_REF` (if not derivable from `SUPABASE_URL`)

**Verification is mandatory after applying:**
- Run `npx tsx scripts/verify-live-deployment.ts`
- Validate the specific schema expectation (e.g. column type) before proceeding.

---

## üö´ NO PLACEHOLDERS / NO MOCKS IN THE APP (PRODUCTION BEHAVIOR)

**Rule:** Do not implement or rely on ‚Äútemporary placeholders‚Äù or ‚Äúmock API data‚Äù in runtime app flows.

- **Course generation must be real**: if LLM fill/validation/persistence fails, the job must **FAIL LOUD** with a precise error. Do NOT return placeholder courses.
- **No mocked app behavior** behind flags for production flows (e.g. `VITE_USE_MOCK`) unless the user explicitly asks for a mock-only local dev mode.
- When failure happens, surface: **what is missing**, **where**, and **how to fix** (env var name, migration, missing function deploy, etc.).

---

## ‚úÖ E2E Truth Policy (REAL DB + REAL LLM ONLY)

**Rule:** E2E tests are only considered ‚Äúpassing‚Äù if they hit:
- a **real database** (Supabase project), and
- **real LLM providers** (no mocked responses)

**Hard rule:** Never present mock test results as ‚Äúsuccess‚Äù. If any part is mocked, label it explicitly as **MOCKED** and do not claim the system works end-to-end.

---

## üöÄ Edge Function Deployment (MANDATORY READING)

**Before deploying ANY Supabase Edge Function, READ `docs/EDGE_DEPLOYMENT_RUNBOOK.md`.**

### Quick Rules (Memorize):
1. **Imports**: Use `npm:@supabase/supabase-js@2` (NOT `esm.sh`)
2. **CORS**: Import `{ stdHeaders, handleOptions }` (NOT `corsHeaders`)
3. **Auth**: Use Hybrid Auth (Agent Token + User Session) for shared functions.
4. **Client**: Create at TOP LEVEL (outside `serve()`)
5. **Verify**: ALWAYS run `npx tsx scripts/verify-live-deployment.ts` after deploy

### 503 = Startup Crash
Check: bad imports, non-existent exports, env var assertions.

### Deployment
```powershell
$env:SUPABASE_ACCESS_TOKEN = "sbp_..."; .\scripts\ci\deploy-functions.ps1 -EnvPath supabase/.deploy.env
npx tsx scripts/verify-live-deployment.ts  # ALWAYS verify after deploy
```

## üìã Mock Coverage Mandate

- `docs/mockups/coverage.json` is the source of truth for every route/state/CTA. Do **not** add or edit mock HTML without updating the matrix.
- Before generating React pages (`scripts/compile-mockups.ts`) you must run `npm run mock:validate` and `npm run test:cta-smoke`. The compile step now halts if required CTAs are missing or miswired, so fix the mock instead of bypassing the check.
- Every CTA must have a visible behavior (toast, BLOCKED banner, navigation, or job). If you temporarily disable a CTA, mark it `data-cta-id="cta-blocked"` and surface a BLOCKED message explaining why.